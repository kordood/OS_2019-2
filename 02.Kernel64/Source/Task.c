/**k.c
 *  date    2009/02/19
 *  author  kkamagui 
 *          Copyright(c)2008 All rights reserved by kkamagui
 *  brief   ?Â½?Å©?? Ã³???Ï´? ?Ô¼??? ???Ãµ? ????
 */

#include "Task.h"
#include "Descriptor.h"

// ?????Ù·? ???? ?Ú·á±¸Á¶
static SCHEDULER gs_stScheduler;
static TCBPOOLMANAGER gs_stTCBPoolManager;

static QWORD gs_qwTicketCount;
//==============================================================================
//  ?Â½?Å© Ç®?? ?Â½?Å© ????
//==============================================================================
/**
 *  ?Â½?Å© Ç® ?Ê±?È­
 */
static void kInitializeTCBPool( void )
{
	int i;

	kMemSet( &( gs_stTCBPoolManager ), 0, sizeof( gs_stTCBPoolManager ) );

	// ?Â½?Å© Ç®?? ???å·¹???? ??Á¤?Ï°? ?Ê±?È­
	gs_stTCBPoolManager.pstStartAddress = ( TCB* ) TASK_TCBPOOLADDRESS;
	kMemSet( TASK_TCBPOOLADDRESS, 0, sizeof( TCB ) * TASK_MAXCOUNT );

	// TCB?? ID ?Ò´?
	for( i = 0 ; i < TASK_MAXCOUNT ; i++ )
	{
		gs_stTCBPoolManager.pstStartAddress[ i ].stLink.qwID = i;
	}

	// TCB?? ?Ö´? ?????? ?Ò´??? È½???? ?Ê±?È­
	gs_stTCBPoolManager.iMaxCount = TASK_MAXCOUNT;
	gs_stTCBPoolManager.iAllocatedCount = 1;
}

/**
 *  TCB?? ?Ò´? ??À½
 */
static TCB* kAllocateTCB( void )
{
	TCB* pstEmptyTCB;
	int i;

	if( gs_stTCBPoolManager.iUseCount == gs_stTCBPoolManager.iMaxCount )
	{
		return NULL;
	}

	for( i = 0 ; i < gs_stTCBPoolManager.iMaxCount ; i++ )
	{
		// ID?? ??À§ 32??Æ®?? 0?Ì¸? ?Ò´????? ??Àº TCB
		if( ( gs_stTCBPoolManager.pstStartAddress[ i ].stLink.qwID >> 32 ) == 0 )
		{
			pstEmptyTCB = &( gs_stTCBPoolManager.pstStartAddress[ i ] );
			break;
		}
	}

	// ??À§ 32??Æ®?? 0?? ?Æ´? ??À¸?? ??Á¤?Ø¼? ?Ò´??? TCB?? ??Á¤
	pstEmptyTCB->stLink.qwID = ( ( QWORD ) gs_stTCBPoolManager.iAllocatedCount << 32 ) | i;
	gs_stTCBPoolManager.iUseCount++;
	gs_stTCBPoolManager.iAllocatedCount++;
	if( gs_stTCBPoolManager.iAllocatedCount == 0 )
	{
		gs_stTCBPoolManager.iAllocatedCount = 1;
	}

	return pstEmptyTCB;
}

/**
 *  TCB?? ??Á¦??
 */
static void kFreeTCB( QWORD qwID )
{
	int i;

	// ?Â½?Å© ID?? ??À§ 32??Æ®?? ?Îµ??? ????À» ??
	i = GETTCBOFFSET( qwID );

	// TCB?? ?Ê±?È­?Ï°? ID ??Á¤
	kMemSet( &( gs_stTCBPoolManager.pstStartAddress[ i ].stContext ), 0, sizeof( CONTEXT ) );
	gs_stTCBPoolManager.pstStartAddress[ i ].stLink.qwID = i;

	gs_stTCBPoolManager.iUseCount--;
}

/**
 *  ?Â½?Å©?? ????
 *      ?Â½?Å© ID?? ?????? ???? Ç®???? ???? ?Úµ? ?Ò´?
 *      ?Á·Î¼??? ?? ?????? ???? ???? ????
 */
TCB* kCreateTask( QWORD qwFlags, void* pvMemoryAddress, QWORD qwMemorySize, 
		QWORD qwEntryPointAddress )
{
	TCB* pstTask, * pstProcess;
	void* pvStackAddress;
	BOOL bPreviousFlag;

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();    
	pstTask = kAllocateTCB();
	if( pstTask == NULL )
	{
		// ?Ó°è¿µ?? ??
		kUnlockForSystemData( bPreviousFlag );
		return NULL;
	}

	// ???? ?Á·Î¼??? ?Ç´? ?????å°¡ ???? ?Á·Î¼????? ?Ë»?
	pstProcess = kGetProcessByThread( kGetRunningTask() );
	// ???? ?Á·Î¼????? ???Ù¸? ?Æ¹??? ?Û¾??? ???? ??À½
	if( pstProcess == NULL )
	{
		kFreeTCB( pstTask->stLink.qwID );
		// ?Ó°? ???? ??
		kUnlockForSystemData( bPreviousFlag );
		return NULL;
	}

	// ?????å¸¦ ?????Ï´? ???????? ???? ???? ?Á·Î¼????? ?Ú½? ?????? ????Æ®?? ??????
	if( qwFlags & TASK_FLAGS_THREAD )
	{
		// ???? ???????? ?Á·Î¼????? Ã£?Æ¼? ?????? ?????å¿¡ ?Á·Î¼??? Á¤???? ????
		pstTask->qwParentProcessID = pstProcess->stLink.qwID;
		pstTask->pvMemoryAddress = pstProcess->pvMemoryAddress;
		pstTask->qwMemorySize = pstProcess->qwMemorySize;

		// ?Î¸? ?Á·Î¼????? ?Ú½? ?????? ????Æ®?? ?ß°?
		kAddListToTail( &( pstProcess->stChildThreadList ), &( pstTask->stThreadLink ) );
	}
	// ?Á·Î¼????? ?Ä¶????Í·? ?Ñ¾??? ??À» ?×´??? ??Á¤
	else
	{
		pstTask->qwParentProcessID = pstProcess->stLink.qwID;
		pstTask->pvMemoryAddress = pvMemoryAddress;
		pstTask->qwMemorySize = qwMemorySize;
	}
	// ???????? ID?? ?Â½?Å© ID?? ?????Ï°? ??Á¤
	pstTask->stThreadLink.qwID = pstTask->stLink.qwID;    
	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );

	// ?Â½?Å© ID?? ???? ???å·¹?? ????, ??À§ 32??Æ®?? ???? Ç®?? ???Á¼? ???? ????
	pvStackAddress = ( void* ) ( TASK_STACKPOOLADDRESS + ( TASK_STACKSIZE * 
				GETTCBOFFSET( pstTask->stLink.qwID ) ) );

	// TCB?? ??Á¤?? ?? ?Øº? ????Æ®?? ?????Ï¿? ?????Ù¸??? ?? ?Öµ??? ??
	kSetUpTask( pstTask, qwFlags, qwEntryPointAddress, pvStackAddress, 
			TASK_STACKSIZE );

	// ?Ú½? ?????? ????Æ®?? ?Ê±?È­
	kInitializeList( &( pstTask->stChildThreadList ) );

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	// ?Â½?Å©?? ?Øº? ????Æ®?? ????
	kAddTaskToReadyList( pstTask );

	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );

	return pstTask;
}

/**
 *  ?Ä¶????Í¸? ?Ì¿??Ø¼? TCB?? ??Á¤
 */
static void kSetUpTask( TCB* pstTCB, QWORD qwFlags, QWORD qwEntryPointAddress,
		void* pvStackAddress, QWORD qwStackSize )
{
	// ???Ø½?Æ® ?Ê±?È­
	kMemSet( pstTCB->stContext.vqRegister, 0, sizeof( pstTCB->stContext.vqRegister ) );

	// ???Ã¿? ???Ãµ? RSP, RBP ???????? ??Á¤
	pstTCB->stContext.vqRegister[ TASK_RSPOFFSET ] = ( QWORD ) pvStackAddress + 
		qwStackSize - 8;
	pstTCB->stContext.vqRegister[ TASK_RBPOFFSET ] = ( QWORD ) pvStackAddress + 
		qwStackSize - 8;

	// Return Address ?????? kExitTask() ?Ô¼??? ???å·¹???? ?????Ï¿? ?Â½?Å©?? ??Æ®??
	// ????Æ® ?Ô¼??? ??Á®?????? ???Ã¿? kExitTask() ?Ô¼??? ?Ìµ??Ïµ??? ??
	*( QWORD * ) ( ( QWORD ) pvStackAddress + qwStackSize - 8 ) = ( QWORD ) kExitTask;

	// ???×¸?Æ® ?????? ??Á¤
	pstTCB->stContext.vqRegister[ TASK_CSOFFSET ] = GDT_KERNELCODESEGMENT;
	pstTCB->stContext.vqRegister[ TASK_DSOFFSET ] = GDT_KERNELDATASEGMENT;
	pstTCB->stContext.vqRegister[ TASK_ESOFFSET ] = GDT_KERNELDATASEGMENT;
	pstTCB->stContext.vqRegister[ TASK_FSOFFSET ] = GDT_KERNELDATASEGMENT;
	pstTCB->stContext.vqRegister[ TASK_GSOFFSET ] = GDT_KERNELDATASEGMENT;
	pstTCB->stContext.vqRegister[ TASK_SSOFFSET ] = GDT_KERNELDATASEGMENT;

	// RIP ???????Í¿? ???Í·?Æ® ?Ã·??? ??Á¤
	pstTCB->stContext.vqRegister[ TASK_RIPOFFSET ] = qwEntryPointAddress;

	// RFLAGS ?????????? IF ??Æ®(??Æ® 9)?? 1?? ??Á¤?Ï¿? ???Í·?Æ® È°??È­
	pstTCB->stContext.vqRegister[ TASK_RFLAGSOFFSET ] |= 0x0200;

	// ???Ã°? ?Ã·??? ????
	pstTCB->pvStackAddress = pvStackAddress;
	pstTCB->qwStackSize = qwStackSize;
	pstTCB->qwFlags = qwFlags;


	// ?Î¸? ?Á·Î¼????? ?Ú½? ?????? ????Æ®?? ?ß°?
	BYTE bPriority = GETPRIORITY( qwFlags );//????È¯ ???????Ï³??

	switch(bPriority){
		case 0 :
			pstTCB -> qwTicket = TASK_HIGHEST_TICKET;
			gs_qwTicketCount += TASK_HIGHEST_TICKET;;
			break;
		case 1:
			pstTCB -> qwTicket = TASK_HIGH_TICKET;;
			gs_qwTicketCount += TASK_HIGH_TICKET;;
			break;
		case 2 :
			pstTCB -> qwTicket = TASK_MEDIUM_TICKET;;
			gs_qwTicketCount += TASK_MEDIUM_TICKET;;
			break;
		case 3 :
			pstTCB -> qwTicket = TASK_LOW_TICKET;;
			gs_qwTicketCount += TASK_LOW_TICKET;;
			break;
		case 4 :
			pstTCB -> qwTicket = TASK_LOWEST_TICKET;;
			gs_qwTicketCount += TASK_LOWEST_TICKET;;
			break;
		default :
			pstTCB -> qwTicket = 1;
			gs_qwTicketCount += 1;
			break;
	}
	pstTCB->qwStride = STRIDE_N / ( pstTCB->qwTicket );

	TCB* pstTarget = NULL;
	TCB* pstTemp = NULL;
	LIST* pstList = NULL, * pstLastList = NULL;
	LISTLINK* pstLLCur = NULL, * pstLastLL = NULL;
	QWORD qwID = -1, changed = 0; 
	int iTaskCount = 0, j = 0; 

	for( j = 0; j < 2 ; j++){

		// ?? ?? ???? ?? ?? ???? ???? ???? ????? ???? ??
		for( QWORD i = 0 ; i < TASK_MAXREADYLISTCOUNT ; i++ )
		{
			pstList = (LIST*) (&(gs_stScheduler.vstReadyList[ i ])); 
			pstLLCur = (LISTLINK*) kGetHeaderFromList(&(gs_stScheduler.vstReadyList[i]));
			iTaskCount = kGetListCount( &( gs_stScheduler.vstReadyList[ i ] ) ); 

			for( int k = 0; k < iTaskCount ; k++ ){
				pstTemp =  ( TCB* ) kGetTCBInTCBPool( GETTCBOFFSET(pstLLCur->qwID));
				if(pstTarget == NULL || pstTarget->qwPass > pstTemp->qwPass){
					pstTarget = pstTemp;
					pstLastList = pstList;
					pstLastLL = pstLLCur;
					changed = 1; 
				}
				pstLLCur = pstLLCur->pvNext;
			}

		}
		if(pstTarget != NULL)
		{
			break;
		}
	}    

	if(changed)
	{
		pstTCB->qwPass = pstTarget->qwPass;
	}
	//kPrintf("Target's pass: %x stride: %x ticket: %x\n", pstTarget -> qwPass, pstTarget -> qwStride, pstTarget -> qwTicket);
}

//==============================================================================
//  ?????Ù·? ????
//==============================================================================
/**
 *  ?????Ù·??? ?Ê±?È­
 *      ?????Ù·??? ?Ê±?È­?Ï´Âµ? ?Ê¿??? TCB Ç®?? init ?Â½?Å©?? ???? ?Ê±?È­
 */
void kInitializeScheduler( void )
{
	int i;
	TCB* pstTask;

	// ?Â½?Å© Ç® ?Ê±?È­
	kInitializeTCBPool();

	// ?Øº? ????Æ®?? ?ì¼± ??À§?? ???? È½???? ?Ê±?È­?Ï°? ???? ????Æ®?? ?Ê±?È­
	for( i = 0 ; i < TASK_MAXREADYLISTCOUNT ; i++ )
	{
		kInitializeList( &( gs_stScheduler.vstReadyList[ i ] ) );
		gs_stScheduler.viExecuteCount[ i ] = 0;
	}    
	kInitializeList( &( gs_stScheduler.stWaitList ) );

	// TCB?? ?Ò´? ?Þ¾? ????À» ?????? ?Â½?Å©?? Ä¿?? ?????? ?Á·Î¼????? ??Á¤
	pstTask = kAllocateTCB();
	gs_stScheduler.pstRunningTask = pstTask;
	pstTask->qwFlags = TASK_FLAGS_HIGHEST | TASK_FLAGS_PROCESS | TASK_FLAGS_SYSTEM;
	pstTask->qwParentProcessID = pstTask->stLink.qwID;
	pstTask->pvMemoryAddress = ( void* ) 0x100000;
	pstTask->qwMemorySize = 0x500000;
	pstTask->pvStackAddress = ( void* ) 0x600000;
	pstTask->qwStackSize = 0x100000;
	pstTask->qwTicket = 100;
	//gs_qwTicketCount = 100;
	pstTask->qwStride = STRIDE_N / ( pstTask -> qwTicket );

	// ?Á·Î¼??? ??????À» ?????Ï´Âµ? ?????Ï´? ?Ú·á±¸Á¶ ?Ê±?È­
	gs_stScheduler.qwSpendProcessorTimeInIdleTask = 0;
	gs_stScheduler.qwProcessorLoad = 0;
}

/**
 *  ???? ???? ???? ?Â½?Å©?? ??Á¤
 */
void kSetRunningTask( TCB* pstTask )
{
	BOOL bPreviousFlag;

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	gs_stScheduler.pstRunningTask = pstTask;

	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );
}

/**
 *  ???? ???? ???? ?Â½?Å©?? ??È¯
 */
TCB* kGetRunningTask( void )
{
	BOOL bPreviousFlag;
	TCB* pstRunningTask;

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	pstRunningTask = gs_stScheduler.pstRunningTask;

	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );

	return pstRunningTask;
}

/**
 *  ?Â½?Å© ????Æ®???? ??À½À¸?? ?????? ?Â½?Å©?? ??À½
 */
/*
   static TCB* kGetNextTaskToRun( void )
   {
   TCB* pstTarget = NULL;
   int iTaskCount, i, j;

// Å¥?? ?Â½?Å©?? ??À¸?? ???? Å¥?? ?Â½?Å©?? 1È¸?? ?????? ????, ???? Å¥?? ?Á·Î¼?????
// ?çº¸?Ï¿? ?Â½?Å©?? ???????? ???? ?? ??À¸?? NULL?? ???? ?Ñ¹? ?? ????
for( j = 0 ; j < 2 ; j++ )
{
// ??Àº ?ì¼± ??À§???? ??Àº ?ì¼± ??À§???? ????Æ®?? È®???Ï¿? ?????Ù¸??? ?Â½?Å©?? ????
for( i = 0 ; i < TASK_MAXREADYLISTCOUNT ; i++ )
{
iTaskCount = kGetListCount( &( gs_stScheduler.vstReadyList[ i ] ) );

// ???? ?????? È½?öº¸´? ????Æ®?? ?Â½?Å© ???? ?? ??À¸?? ???? ?ì¼± ??À§??
// ?Â½?Å©?? ??????
if( gs_stScheduler.viExecuteCount[ i ] < iTaskCount )
{
pstTarget = ( TCB* ) kRemoveListFromHeader( 
&( gs_stScheduler.vstReadyList[ i ] ) );
gs_stScheduler.viExecuteCount[ i ]++;
break;            
}
// ???? ?????? È½???? ?? ??À¸?? ???? È½???? ?Ê±?È­?Ï°? ??À½ ?ì¼± ??À§?? ?çº¸??
else
{
gs_stScheduler.viExecuteCount[ i ] = 0;
}
}

// ???? ?????? ?Â½?Å©?? Ã£??À¸?? Á¾??
if( pstTarget != NULL )
{
break;
}
}    
return pstTarget;
}

static TCB* kGetNextTaskToRun_Lottery( void )
{
TCB* pstTarget = NULL;
TCB* pstTemp = NULL;
LIST* pstList = NULL;
LISTLINK* pstLinkCurr = NULL;
//QWORD winner = 3; //rand ?? ???? ????

BYTE kSecond;
kReadRTCTime(NULL, NULL, &kSecond);
SSU_srand(kSecond);
//QWORD winner = SSU_rand()%100000;
QWORD winner = 0;
if(gs_qwTicketCount != 0) winner = SSU_rand()%gs_qwTicketCount;
//kPrintf("[%d]\n", gs_qwTicketCount);
//kPrintf("winner : %d\n", winner);
QWORD counter = 0;

// ?? ?? ???? ?? ?? ???? ???? ???? ????? ???? ??
for(int i = 0 ; i < TASK_MAXREADYLISTCOUNT ; i++ )
{
// i?? ???? ? List? ????
pstList = (LIST*) (&(gs_stScheduler.vstReadyList[ i ]));
// ?? List? ??? LISTLINK? ????
pstLinkCurr = (LISTLINK*) kGetHeaderFromList(&(gs_stScheduler.vstReadyList[i]));
// pstLinkCurr ?? ??? ??? List? iterate
while(pstLinkCurr != NULL){
// qwID? ?? TCB? ????
pstTemp = kGetTCBInTCBPool( GETTCBOFFSET(pstLinkCurr->qwID));
// ?? TCB? ticket ??? counter? ????
counter += pstTemp->qwTicket;
// counter ?? winner ???? ??? ?? task? ??????
if(counter > winner)
{
	pstTarget = pstTemp;
	// Print winner, count, qwID
	//kPrintf("winner : %d, counter : %d, qwID : %d\n", winner, counter, pstTarget->stLink.qwID);
	pstTarget->qwSwitchCount++;

	// ???? TCB? LISTLINK? LIST?? ?????
	kRemoveList(pstList, pstLinkCurr->qwID);
	break;
}
else
pstLinkCurr = pstLinkCurr->pvNext;
}
// ?? ??? ???? ???? ??
if(pstTarget != NULL)
	break;
	}
return pstTarget;
}
	*/
static TCB* kGetNextTaskToRun_Stride( void ) // Stride scheduler
{
	TCB* pstTarget = NULL;
	TCB* pstTemp = NULL;
	LIST* pstList = NULL, * pstLastList = NULL;
	LISTLINK* pstLLCur = NULL, * pstLastLL = NULL;
	QWORD qwID = -1, changed = 0; 
	int iTaskCount = 0, j = 0; 

	for( j = 0; j < 2 ; j++){

		// ?? ?? ???? ?? ?? ???? ???? ???? ????? ???? ??
		for( QWORD i = 0 ; i < TASK_MAXREADYLISTCOUNT ; i++ )
		{
			pstList = (LIST*) (&(gs_stScheduler.vstReadyList[ i ])); 
			pstLLCur = (LISTLINK*) kGetHeaderFromList(&(gs_stScheduler.vstReadyList[i]));
			iTaskCount = kGetListCount( &( gs_stScheduler.vstReadyList[ i ] ) ); 

			for( int k = 0; k < iTaskCount ; k++ ){
				pstTemp =  ( TCB* ) kGetTCBInTCBPool( GETTCBOFFSET(pstLLCur->qwID));
				if(pstTarget == NULL || pstTarget->qwPass >= pstTemp->qwPass){
					pstTarget = pstTemp;
					pstLastList = pstList;
					pstLastLL = pstLLCur;
					changed = 1; 
				}
				pstLLCur = pstLLCur->pvNext;
			}

		}
		if(pstTarget != NULL)
		{
			break;
		}
	}    

	if(changed){
		kRemoveList(pstLastList, pstLastLL->qwID);
	}    

	pstTarget->qwPass += pstTarget->qwStride;
	pstTarget->qwSwitchCount++;

	return pstTarget;
}

/**
 *  ?Â½?Å©?? ?????Ù·??? ?Øº? ????Æ®?? ????
 */
static BOOL kAddTaskToReadyList( TCB* pstTask )
{
	BYTE bPriority;

	bPriority = GETPRIORITY( pstTask->qwFlags );
	if( bPriority == TASK_FLAGS_WAIT )
	{
		kAddListToTail( &( gs_stScheduler.stWaitList ), pstTask );
		return TRUE;
	}
	else if( bPriority >= TASK_MAXREADYLISTCOUNT )
	{
		return FALSE;
	}

	kAddListToTail( &( gs_stScheduler.vstReadyList[ bPriority ] ), pstTask );
	return TRUE;
}

/**
 *  ?Øº? Å¥???? ?Â½?Å©?? Á¦??
 */
static TCB* kRemoveTaskFromReadyList( QWORD qwTaskID )
{
	TCB* pstTarget;
	BYTE bPriority;

	// ?Â½?Å© ID?? À¯È¿???? ??À¸?? ????
	if( GETTCBOFFSET( qwTaskID ) >= TASK_MAXCOUNT )
	{
		return NULL;
	}

	// TCB Ç®???? ?Ø´? ?Â½?Å©?? TCB?? Ã£?? ??Á¦?? ID?? ??Ä¡?Ï´Â°? È®??
	pstTarget = &( gs_stTCBPoolManager.pstStartAddress[ GETTCBOFFSET( qwTaskID ) ] );
	if( pstTarget->stLink.qwID != qwTaskID )
	{
		return NULL;
	}

	// ?Â½?Å©?? Á¸???Ï´? ?Øº? ????Æ®???? ?Â½?Å© Á¦??
	bPriority = GETPRIORITY( pstTarget->qwFlags );
	if( bPriority >= TASK_MAXREADYLISTCOUNT )
	{
		return NULL;
	}    

	pstTarget = kRemoveList( &( gs_stScheduler.vstReadyList[ bPriority ]), 
			qwTaskID );
	return pstTarget;
}

/**
 *  ?Â½?Å©?? ?ì¼± ??À§?? ??????
 */
BOOL kChangePriority( QWORD qwTaskID, BYTE bPriority )
{
	TCB* pstTarget;
	BOOL bPreviousFlag;

	if( bPriority > TASK_MAXREADYLISTCOUNT )
	{
		return FALSE;
	}

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	// ???? ???????? ?Â½?Å©?Ì¸? ?ì¼± ??À§?? ????
	// PIT ??Æ®?Ñ·??? ???Í·?Æ®(IRQ 0)?? ?ß»??Ï¿? ?Â½?Å© ??È¯?? ?????? ?? ?????? 
	// ?ì¼± ??À§?? ????Æ®?? ?Ìµ?
	pstTarget = gs_stScheduler.pstRunningTask;
	if( pstTarget->stLink.qwID == qwTaskID )
	{
		SETPRIORITY( pstTarget->qwFlags, bPriority );
		//???? Æ¼?? ???? ??Ã¼ Æ¼?Ï¼ö¿¡¼? ???Ö°?, 
		//?ì¼±??À§?? ???? Æ¼?Ï¼??? ?????Ø´?.
		gs_qwTicketCount -= pstTarget -> qwTicket;
		switch(bPriority){
			case 0 :
				pstTarget -> qwTicket = TASK_HIGHEST_TICKET;
				gs_qwTicketCount += TASK_HIGHEST_TICKET;
				break;
			case 1:
				pstTarget -> qwTicket = TASK_HIGH_TICKET;
				gs_qwTicketCount += TASK_HIGH_TICKET;
				break;
			case 2 :
				pstTarget -> qwTicket = TASK_MEDIUM_TICKET;
				gs_qwTicketCount += TASK_MEDIUM_TICKET;
				break;
			case 3 :
				pstTarget -> qwTicket = TASK_LOW_TICKET;
				gs_qwTicketCount += TASK_LOW_TICKET;
				break;
			case 4 :
				pstTarget -> qwTicket = TASK_LOWEST_TICKET;
				gs_qwTicketCount += TASK_LOWEST_TICKET;
				break;
			default :
				pstTarget -> qwTicket = 1;
				gs_qwTicketCount += 1;
				break;
		}
		pstTarget -> qwStride = STRIDE_N / ( pstTarget -> qwTicket );
	}
	// ???????? ?Â½?Å©?? ?Æ´Ï¸? ?Øº? ????Æ®???? Ã£?Æ¼? ?Ø´? ?ì¼± ??À§?? ????Æ®?? ?Ìµ?
	else
	{
		// ?Øº? ????Æ®???? ?Â½?Å©?? Ã£?? ???Ï¸? ??Á¢ ?Â½?Å©?? Ã£?Æ¼? ?ì¼± ??À§?? ??Á¤
		pstTarget = kRemoveTaskFromReadyList( qwTaskID );
		if( pstTarget == NULL )
		{
			// ?Â½?Å© ID?? ??Á¢ Ã£?Æ¼? ??Á¤
			pstTarget = kGetTCBInTCBPool( GETTCBOFFSET( qwTaskID ) );
			if( pstTarget != NULL )
			{
				// ?ì¼± ??À§?? ??Á¤
				gs_qwTicketCount -= pstTarget -> qwTicket;
				SETPRIORITY( pstTarget->qwFlags, bPriority );
				switch(bPriority){
					case 0 :
						pstTarget -> qwTicket = TASK_HIGHEST_TICKET;
						gs_qwTicketCount += TASK_HIGHEST_TICKET;
						break;
					case 1:
						pstTarget -> qwTicket = TASK_HIGH_TICKET;
						gs_qwTicketCount += TASK_HIGH_TICKET;
						break;
					case 2 :
						pstTarget -> qwTicket = TASK_MEDIUM_TICKET;
						gs_qwTicketCount += TASK_MEDIUM_TICKET;
						break;
					case 3 :
						pstTarget -> qwTicket = TASK_LOW_TICKET;
						gs_qwTicketCount += TASK_LOW_TICKET;
						break;
					case 4 :
						pstTarget -> qwTicket = TASK_LOWEST_TICKET;
						gs_qwTicketCount += TASK_LOWEST_TICKET;
						break;
					default :
						pstTarget -> qwTicket = 1;
						gs_qwTicketCount += 1;
						break;
				}
		pstTarget -> qwStride = STRIDE_N / ( pstTarget -> qwTicket );
			}
		}
		else
		{
			// ?ì¼± ??À§?? ??Á¤?Ï°? ?Øº? ????Æ®?? ?Ù½? ????
			gs_qwTicketCount -= pstTarget -> qwTicket;
			SETPRIORITY( pstTarget->qwFlags, bPriority );
			switch(bPriority){
				case 0 :
					pstTarget -> qwTicket = TASK_HIGHEST_TICKET;
					gs_qwTicketCount += TASK_HIGHEST_TICKET;
					break;
				case 1:
					pstTarget -> qwTicket = TASK_HIGH_TICKET;
					gs_qwTicketCount += TASK_HIGH_TICKET;
					break;
				case 2 :
					pstTarget -> qwTicket = TASK_MEDIUM_TICKET;
					gs_qwTicketCount += TASK_MEDIUM_TICKET;
					break;
				case 3 :
					pstTarget -> qwTicket = TASK_LOW_TICKET;
					gs_qwTicketCount += TASK_LOW_TICKET;
					break;
				case 4 :
					pstTarget -> qwTicket = TASK_LOWEST_TICKET;
					gs_qwTicketCount += TASK_LOWEST_TICKET;
					break;
				default :
					pstTarget -> qwTicket = 1;
					gs_qwTicketCount += 1;
					break;
			}
		pstTarget -> qwStride = STRIDE_N / ( pstTarget -> qwTicket );
			kAddTaskToReadyList( pstTarget );
		}
	}
	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );
	return TRUE;    
}

/**
 *  ?Ù¸? ?Â½?Å©?? Ã£?Æ¼? ??È¯
 *      ???Í·?Æ®?? ???Ü°? ?ß»???À» ?? È£???Ï¸? ?Èµ?
 */
void kSchedule( void )
{
	TCB* pstRunningTask, * pstNextTask;
	BOOL bPreviousFlag;
	// ??È¯?? ?Â½?Å©?? ?Ö¾??? ??
	if( kGetReadyTaskCount() < 1 )
	{
		return ;
	}

	// ??È¯?Ï´? ???? ???Í·?Æ®?? ?ß»??Ï¿? ?Â½?Å© ??È¯?? ?? ?Ï¾î³ª?? ?????Ï¹Ç·? ??È¯?Ï´? 
	// ???? ???Í·?Æ®?? ?ß»????? ???Ïµ??? ??Á¤
	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	// ?????? ??À½ ?Â½?Å©?? ??À½
	pstNextTask = kGetNextTaskToRun_Stride();
	if( pstNextTask == NULL )
	{
		// ?Ó°? ???? ??
		kUnlockForSystemData( bPreviousFlag );
		return ;
	}

	// ???? ???????? ?Â½?Å©?? Á¤???? ??Á¤?? ?? ???Ø½?Æ® ??È¯
	pstRunningTask = gs_stScheduler.pstRunningTask; 
	gs_stScheduler.pstRunningTask = pstNextTask;

	// À¯?? ?Â½?Å©???? ??È¯?Ç¾??Ù¸? ?????? ?Á·Î¼??? ?Ã°?À» ?õ°¡½?Å´
	if( ( pstRunningTask->qwFlags & TASK_FLAGS_IDLE ) == TASK_FLAGS_IDLE )
	{
		gs_stScheduler.qwSpendProcessorTimeInIdleTask += 
			TASK_PROCESSORTIME - gs_stScheduler.iProcessorTime;
	}

	// ?Â½?Å© Á¾?? ?Ã·??×°? ??Á¤?? ???? ???Ø½?Æ®?? ?????? ?Ê¿ä°¡ ??À¸?Ç·?, ???? ????Æ®??
	// ?????Ï°? ???Ø½?Æ® ??È¯
	if( pstRunningTask->qwFlags & TASK_FLAGS_ENDTASK )
	{
		kAddListToTail( &( gs_stScheduler.stWaitList ), pstRunningTask );
		//kPrintf("ID: [%d] pass: %x stride: %x ticket: %x\n", pstNextTask->stLink.qwID, pstNextTask -> qwPass, pstNextTask -> qwStride, pstNextTask -> qwTicket);
		kSwitchContext( NULL, &( pstNextTask->stContext ) );
	}
	else
	{
		kAddTaskToReadyList( pstRunningTask );
		kSwitchContext( &( pstRunningTask->stContext ), &( pstNextTask->stContext ) );
	}

	// ?Á·Î¼??? ???? ?Ã°?À» ??????Æ®
	gs_stScheduler.iProcessorTime = TASK_PROCESSORTIME;

	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );
}

/**
 *  ???Í·?Æ®?? ?ß»???À» ??, ?Ù¸? ?Â½?Å©?? Ã£?? ??È¯
 *      ?Ýµ??? ???Í·?Æ®?? ???Ü°? ?ß»???À» ?? È£???Ø¾? ??
 */
BOOL kScheduleInInterrupt( void )
{
	TCB* pstRunningTask, * pstNextTask;
	char* pcContextAddress;
	BOOL bPreviousFlag;

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	// ??È¯?? ?Â½?Å©?? ??À¸?? Á¾??
	pstNextTask = kGetNextTaskToRun_Stride();
	if( pstNextTask == NULL )
	{
		// ?Ó°? ???? ??
		kUnlockForSystemData( bPreviousFlag );
		return FALSE;
	}

	//==========================================================================
	//  ?Â½?Å© ??È¯ Ã³??   
	//      ???Í·?Æ® ?Úµé·¯???? ?????? ???Ø½?Æ®?? ?Ù¸? ???Ø½?Æ®?? ???î¾²?? ????À¸?? Ã³??
	//==========================================================================
	pcContextAddress = ( char* ) IST_STARTADDRESS + IST_SIZE - sizeof( CONTEXT );

	// ???? ???????? ?Â½?Å©?? Á¤???? ??Á¤?? ?? ???Ø½?Æ® ??È¯
	pstRunningTask = gs_stScheduler.pstRunningTask;
	gs_stScheduler.pstRunningTask = pstNextTask;

	// À¯?? ?Â½?Å©???? ??È¯?Ç¾??Ù¸? ?????? Tick Count?? ?õ°¡½?Å´
	if( ( pstRunningTask->qwFlags & TASK_FLAGS_IDLE ) == TASK_FLAGS_IDLE )
	{
		gs_stScheduler.qwSpendProcessorTimeInIdleTask += TASK_PROCESSORTIME;
	}    

	// ?Â½?Å© Á¾?? ?Ã·??×°? ??Á¤?? ????, ???Ø½?Æ®?? ???????? ?Ê°? ???? ????Æ®???? ????
	if( pstRunningTask->qwFlags & TASK_FLAGS_ENDTASK )
	{    
		kAddListToTail( &( gs_stScheduler.stWaitList ), pstRunningTask );
	}
	// ?Â½?Å©?? Á¾?????? ??À¸?? IST?? ?Ö´? ???Ø½?Æ®?? ?????Ï°?, ???? ?Â½?Å©?? ?Øº? ????Æ®??
	// ?Å±?
	else
	{
		kMemCpy( &( pstRunningTask->stContext ), pcContextAddress, sizeof( CONTEXT ) );
		kAddTaskToReadyList( pstRunningTask );
	}
	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );

	// ??È¯?Ø¼? ?????? ?Â½?Å©?? Running Task?? ??Á¤?Ï°? ???Ø½?Æ®?? IST?? ?????Ø¼?
	// ?Úµ?À¸?? ?Â½?Å© ??È¯?? ?Ï¾î³ª???? ??
	kMemCpy( pcContextAddress, &( pstNextTask->stContext ), sizeof( CONTEXT ) );

	// ?Á·Î¼??? ???? ?Ã°?À» ??????Æ®
	gs_stScheduler.iProcessorTime = TASK_PROCESSORTIME;
	return TRUE;
}

/**
 *  ?Á·Î¼????? ?????? ?? ?Ö´? ?Ã°?À» ?Ï³? ????
 */
void kDecreaseProcessorTime( void )
{
	if( gs_stScheduler.iProcessorTime > 0 )
	{
		gs_stScheduler.iProcessorTime--;
	}
}

/**
 *  ?Á·Î¼????? ?????? ?? ?Ö´? ?Ã°??? ?? ?Ç¾????? ???Î¸? ??È¯
 */
BOOL kIsProcessorTimeExpired( void )
{
	if( gs_stScheduler.iProcessorTime <= 0 )
	{
		return TRUE;
	}
	return FALSE;
}

/**
 *  ?Â½?Å©?? Á¾??
 */
BOOL kEndTask( QWORD qwTaskID )
{
	TCB* pstTarget;
	BYTE bPriority;
	BOOL bPreviousFlag;

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	// ???? ???????? ?Â½?Å©?Ì¸? EndTask ??Æ®?? ??Á¤?Ï°? ?Â½?Å©?? ??È¯
	pstTarget = gs_stScheduler.pstRunningTask;
	if( pstTarget->stLink.qwID == qwTaskID )
	{
		pstTarget->qwFlags |= TASK_FLAGS_ENDTASK;
		SETPRIORITY( pstTarget->qwFlags, TASK_FLAGS_WAIT );

		// ?Ó°? ???? ??
		kUnlockForSystemData( bPreviousFlag );

		kSchedule();

		// ?Â½?Å©?? ??È¯ ?Ç¾?À¸?Ç·? ?Æ·? ?Úµ??? ???? ???????? ??À½
		while( 1 ) ;
	}
	// ???? ???? ?Â½?Å©?? ?Æ´Ï¸? ?Øº? Å¥???? ??Á¢ Ã£?Æ¼? ???? ????Æ®?? ????
	else
	{
		// ?Øº? ????Æ®???? ?Â½?Å©?? Ã£?? ???Ï¸? ??Á¢ ?Â½?Å©?? Ã£?Æ¼? ?Â½?Å© Á¾?? ??Æ®??
		// ??Á¤
		pstTarget = kRemoveTaskFromReadyList( qwTaskID );
		if( pstTarget == NULL )
		{
			// ?Â½?Å© ID?? ??Á¢ Ã£?Æ¼? ??Á¤
			pstTarget = kGetTCBInTCBPool( GETTCBOFFSET( qwTaskID ) );
			if( pstTarget != NULL )
			{
				pstTarget->qwFlags |= TASK_FLAGS_ENDTASK;
				SETPRIORITY( pstTarget->qwFlags, TASK_FLAGS_WAIT );
			}
			// ?Ó°? ???? ??
			kUnlockForSystemData( bPreviousFlag );
			return TRUE;
		}

		pstTarget->qwFlags |= TASK_FLAGS_ENDTASK;
		SETPRIORITY( pstTarget->qwFlags, TASK_FLAGS_WAIT );
		kAddListToTail( &( gs_stScheduler.stWaitList ), pstTarget );
	}
	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );
	return TRUE;
}

/**
 *  ?Â½?Å©?? ?Ú½?À» Á¾????
 */
void kExitTask( void )
{
	kEndTask( gs_stScheduler.pstRunningTask->stLink.qwID );
}

/**
 *  ?Øº? Å¥?? ?Ö´? ???? ?Â½?Å©?? ???? ??È¯
 */
int kGetReadyTaskCount( void )
{
	int iTotalCount = 0;
	int i;
	BOOL bPreviousFlag;

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	// ???? ?Øº? Å¥?? È®???Ï¿? ?Â½?Å© ?????? ????
	for( i = 0 ; i < TASK_MAXREADYLISTCOUNT ; i++ )
	{
		iTotalCount += kGetListCount( &( gs_stScheduler.vstReadyList[ i ] ) );
	}

	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );
	return iTotalCount ;
}

/**
 *  ??Ã¼ ?Â½?Å©?? ???? ??È¯
 */ 
int kGetTaskCount( void )
{
	int iTotalCount;
	BOOL bPreviousFlag;

	// ?Øº? Å¥?? ?Â½?Å© ???? ???? ??, ???? Å¥?? ?Â½?Å© ???? ???? ???? ???? ?Â½?Å© ???? ????
	iTotalCount = kGetReadyTaskCount();

	// ?Ó°? ???? ????
	bPreviousFlag = kLockForSystemData();

	iTotalCount += kGetListCount( &( gs_stScheduler.stWaitList ) ) + 1;

	// ?Ó°? ???? ??
	kUnlockForSystemData( bPreviousFlag );
	return iTotalCount;
}

/**
 *  TCB Ç®???? ?Ø´? ???Á¼??? TCB?? ??È¯
 */
TCB* kGetTCBInTCBPool( int iOffset )
{
	if( ( iOffset < -1 ) && ( iOffset > TASK_MAXCOUNT ) )
	{
		return NULL;
	}

	return &( gs_stTCBPoolManager.pstStartAddress[ iOffset ] );
}

/**
 *  ?Â½?Å©?? Á¸???Ï´??? ???Î¸? ??È¯
 */
BOOL kIsTaskExist( QWORD qwID )
{
	TCB* pstTCB;

	// ID?? TCB?? ??È¯
	pstTCB = kGetTCBInTCBPool( GETTCBOFFSET( qwID ) );
	// TCB?? ???Å³? ID?? ??Ä¡???? ??À¸?? Á¸?????? ?Ê´? ????
	if( ( pstTCB == NULL ) || ( pstTCB->stLink.qwID != qwID ) )
	{
		return FALSE;
	}
	return TRUE;
}

/**
 *  ?Á·Î¼????? ??????À» ??È¯
 */
QWORD kGetProcessorLoad( void )
{
	return gs_stScheduler.qwProcessorLoad;
}

/**
 *  ?????å°¡ ?Ò¼Óµ? ?Á·Î¼????? ??È¯
 */
static TCB* kGetProcessByThread( TCB* pstThread )
{
	TCB* pstProcess;

	// ???? ???? ?Á·Î¼????Ì¸? ?Ú½?À» ??È¯
	if( pstThread->qwFlags & TASK_FLAGS_PROCESS )
	{
		return pstThread;
	}

	// ???? ?Á·Î¼????? ?Æ´Ï¶???, ?Î¸? ?Á·Î¼????? ??Á¤?? ?Â½?Å© ID?? ???? 
	// TCB Ç®???? ?Â½?Å© ?Ú·á±¸Á¶ ????
	pstProcess = kGetTCBInTCBPool( GETTCBOFFSET( pstThread->qwParentProcessID ) );

	// ???? ?Á·Î¼????? ???Å³?, ?Â½?Å© ID?? ??Ä¡???? ?Ê´Â´Ù¸? NULLÀ» ??È¯
	if( ( pstProcess == NULL ) || ( pstProcess->stLink.qwID != pstThread->qwParentProcessID ) )
	{
		return NULL;
	}

	return pstProcess;
}

//==============================================================================
//  À¯?? ?Â½?Å© ????
//==============================================================================
/**
 *  À¯?? ?Â½?Å©
 *      ???? Å¥?? ??Á¦ ???????? ?Â½?Å©?? Á¤??
 */
void kIdleTask( void )
{
	TCB* pstTask, * pstChildThread, * pstProcess;
	QWORD qwLastMeasureTickCount, qwLastSpendTickInIdleTask;
	QWORD qwCurrentMeasureTickCount, qwCurrentSpendTickInIdleTask;
	BOOL bPreviousFlag;
	int i, iCount;
	QWORD qwTaskID;
	void* pstThreadLink;
	// ?Á·Î¼??? ???ë·® ????À» À§?? ???? Á¤???? ????
	qwLastSpendTickInIdleTask = gs_stScheduler.qwSpendProcessorTimeInIdleTask;
	qwLastMeasureTickCount = kGetTickCount();

	while( 1 )
	{
		// ???? ???Â¸? ????
		qwCurrentMeasureTickCount = kGetTickCount();
		qwCurrentSpendTickInIdleTask = gs_stScheduler.qwSpendProcessorTimeInIdleTask;

		// ?Á·Î¼??? ???ë·®À» ????
		// 100 - ( À¯?? ?Â½?Å©?? ?????? ?Á·Î¼??? ?Ã°? ) * 100 / ( ?Ã½??? ??Ã¼???? 
		// ?????? ?Á·Î¼??? ?Ã°? )
		if( qwCurrentMeasureTickCount - qwLastMeasureTickCount == 0 )
		{
			gs_stScheduler.qwProcessorLoad = 0;
		}
		else
		{
			gs_stScheduler.qwProcessorLoad = 100 - 
				( qwCurrentSpendTickInIdleTask - qwLastSpendTickInIdleTask ) * 
				100 /( qwCurrentMeasureTickCount - qwLastMeasureTickCount );
		}

		// ???? ???Â¸? ???? ???Â¿? ????
		qwLastMeasureTickCount = qwCurrentMeasureTickCount;
		qwLastSpendTickInIdleTask = qwCurrentSpendTickInIdleTask;

		// ?Á·Î¼????? ???Ï¿? ???? ???? ??
		kHaltProcessorByLoad();

		// ???? Å¥?? ???????? ?Â½?Å©?? ??À¸?? ?Â½?Å©?? Á¾????
		if( kGetListCount( &( gs_stScheduler.stWaitList ) ) >= 0 )
		{
			while( 1 )
			{
				// ?Ó°? ???? ????
				bPreviousFlag = kLockForSystemData();                
				pstTask = kRemoveListFromHeader( &( gs_stScheduler.stWaitList ) );
				if( pstTask == NULL )
				{
					// ?Ó°? ???? ??
					kUnlockForSystemData( bPreviousFlag );
					break;
				}

				if( pstTask->qwFlags & TASK_FLAGS_PROCESS )
				{
					// ?Á·Î¼????? Á¾???? ?? ?Ú½? ?????å°¡ Á¸???Ï¸? ?????å¸¦ ???? 
					// Á¾???Ï°?, ?Ù½? ?Ú½? ?????? ????Æ®?? ????
					iCount = kGetListCount( &( pstTask->stChildThreadList ) );
					for( i = 0 ; i < iCount ; i++ )
					{
						// ?????? ??Å©?? ???å·¹?????? ???? ?????å¸¦ Á¾????Å´
						pstThreadLink = ( TCB* ) kRemoveListFromHeader( 
								&( pstTask->stChildThreadList ) );
						if( pstThreadLink == NULL )
						{
							break;
						}

						// ?Ú½? ?????? ????Æ®?? ?????? Á¤???? ?Â½?Å© ?Ú·á±¸Á¶?? ?Ö´? 
						// stThreadLink?? ???? ???å·¹???Ì¹Ç·?, ?Â½?Å© ?Ú·á±¸Á¶?? ????
						// ???å·¹???? ???Ï·Á¸? ?????? ?????? ?Ê¿???
						pstChildThread = GETTCBFROMTHREADLINK( pstThreadLink );

						// ?Ù½? ?Ú½? ?????? ????Æ®?? ?????Ï¿? ?Ø´? ?????å°¡ Á¾???? ??
						// ?Ú½? ?????å°¡ ?Á·Î¼????? Ã£?? ?????? ????Æ®???? Á¦???Ïµ??? ??
						kAddListToTail( &( pstTask->stChildThreadList ),
								&( pstChildThread->stThreadLink ) );

						// ?Ú½? ?????å¸¦ Ã£?Æ¼? Á¾??
						kEndTask( pstChildThread->stLink.qwID );
					}

					// ???? ?Ú½? ?????å°¡ ?????Ö´Ù¸? ?Ú½? ?????å°¡ ?? Á¾???? ??????
					// ???Ù·Á¾? ?Ï¹Ç·? ?Ù½? ???? ????Æ®?? ????
					if( kGetListCount( &( pstTask->stChildThreadList ) ) > 0 )
					{
						kAddListToTail( &( gs_stScheduler.stWaitList ), pstTask );

						// ?Ó°? ???? ??
						kUnlockForSystemData( bPreviousFlag );
						continue;
					}
					// ?Á·Î¼????? Á¾???Ø¾? ?Ï¹Ç·? ?Ò´? ??Àº ?Þ¸??? ????À» ??Á¦
					else
					{
						// TODO: ???Ä¿? ?Úµ? ????
					}
				}                
				else if( pstTask->qwFlags & TASK_FLAGS_THREAD )
				{
					// ?????????? ?Á·Î¼????? ?Ú½? ?????? ????Æ®???? Á¦??
					pstProcess = kGetProcessByThread( pstTask );
					if( pstProcess != NULL )
					{
						kRemoveList( &( pstProcess->stChildThreadList ), pstTask->stLink.qwID );
					}
				}

				qwTaskID = pstTask->stLink.qwID;
				kFreeTCB( qwTaskID );
				// ?Ó°? ???? ??
				kUnlockForSystemData( bPreviousFlag );

				kPrintf( "IDLE: Task ID[0x%q] is completely ended.\n", 
						qwTaskID );
			}
		}

		kSchedule();
	}
}

/**
 *  ??Á¤?? ?Á·Î¼??? ???Ï¿? ???? ?Á·Î¼????? ???? ??
 */
void kHaltProcessorByLoad( void )
{
	if( gs_stScheduler.qwProcessorLoad < 40 )
	{
		kHlt();
		kHlt();
		kHlt();
	}
	else if( gs_stScheduler.qwProcessorLoad < 80 )
	{
		kHlt();
		kHlt();
	}
	else if( gs_stScheduler.qwProcessorLoad < 95 )
	{
		kHlt();
	}
}

// SSU_rand
SSU_srand(unsigned int seed){
	SSU_next = seed;
}

int SSU_rand(void){
	SSU_next = (SSU_next * 1103515245 + 5571031)>>16;
	return SSU_next;
}
